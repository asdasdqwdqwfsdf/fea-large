#!python

from sys import argv,exit
from math import fabs
from base import Point
from base import isempty,skipwhitespaces,iscomment,removeempty
from base import removecomments,read_and_clear_lines,unique,parse_filename


# tiny allowed error
epsilon = 0.0000000000001
my_epsilon = 0.0001 
# function for retriving 10-noded tetraedras from .1.ele, .1.node and .1.face
# files, generated by tetgen, and export this data to matlab structures
class ansys_importer:
  def __init__(self,displ = 0.05,nodal_yforce = 2.0833333,forces = False):
    self.nodes = []
    self.elements = []
    self.presc = []
    self.fixed = []
    self.displ = displ
    self.nodal_yforce = nodal_yforce
    self.use_forces = forces
    self.filename = ""
    self.min = Point()
    self.max = Point()
    self.surface_elements = []
	
  def read_nodes(self,nodename):
    self.nodes = []
    lines = read_and_clear_lines(nodename)
    for line in lines:
      line_values = line.split()
      # 1st value is a node indes
      if len(line_values) == 3: # only x,y coordinates given
        node = Point(float(line_values[1]),float(line_values[2]))
        self.nodes.append(node)
      else: # x,y,z given
        node = Point(float(line_values[1]),float(line_values[2]),
            float(line_values[3]))
        self.nodes.append(node)

  def read_elements(self,elename):
    lines = read_and_clear_lines(elename)
    for i in range(len(lines)/2):
      line1 = lines[i*2]
      line2 = lines[i*2+1]
      element = []
      line1_vals = [int(i) for i in line1.split()]
      line2_vals = [int(i) for i in line2.split()]
      for i in range(8):
        element.append(line1_vals[i])
      element.append(line2_vals[0])
      element.append(line2_vals[1])
      self.elements.append(element)

  def generate_boundaries(self):
    self.fixed = []
    self.presc = []
    for i in range(len(self.nodes)):
      if fabs(self.nodes[i].y - self.min.y) < my_epsilon:
        self.fixed.append(i+1)
      if fabs(self.nodes[i].y - self.max.y) < my_epsilon:
        self.presc.append(i+1)

  def get_boundary_surface(self,el):
    surface = []
    # go through all 4 surfaces of an element
    # 1: nodes 1,2,3
    if fabs(self.nodes[el[0]-1].y - self.max.y) < my_epsilon and \
       fabs(self.nodes[el[1]-1].y - self.max.y) < my_epsilon and \
       fabs(self.nodes[el[2]-1].y - self.max.y) < my_epsilon:
      surface = [el[0],el[1],el[2],el[4],el[5],el[6]]
    # 2: nodes 2,3,4
    elif fabs(self.nodes[el[1]-1].y - self.max.y) < my_epsilon and \
         fabs(self.nodes[el[2]-1].y - self.max.y) < my_epsilon and \
         fabs(self.nodes[el[3]-1].y - self.max.y) < my_epsilon:
      surface = [el[1],el[2],el[3],el[5],el[9],el[8]]
    # 3: nodes 1,2,4
    elif fabs(self.nodes[el[0]-1].y - self.max.y) < my_epsilon and \
         fabs(self.nodes[el[1]-1].y - self.max.y) < my_epsilon and \
         fabs(self.nodes[el[3]-1].y - self.max.y) < my_epsilon:
      surface = [el[0],el[1],el[3],el[4],el[8],el[7]]
    # 4: nodes 1,4,3
    elif fabs(self.nodes[el[0]-1].y - self.max.y) < my_epsilon and \
         fabs(self.nodes[el[3]-1].y - self.max.y) < my_epsilon and \
         fabs(self.nodes[el[2]-1].y - self.max.y) < my_epsilon:
      surface = [el[0],el[3],el[2],el[7],el[9],el[6]]

    return surface
		
  def generate_surface_forces(self):
    # First of all find all elements with nodes on
    # traction boundary
    for el in self.elements:
      surface = self.get_boundary_surface(el)
      if len(surface):
        self.surface_elements.append(surface)
    print len(self.surface_elements)
    
  def import_files(self,nodename,elename):
    self.read_nodes(nodename)  
    self.read_elements(elename)    
    self.find_minmax_nodes()
    self.generate_boundaries()
    self.generate_surface_forces()

  def find_minmax_nodes(self):
    if len(self.nodes) == 0: 
            return
    self.min.x = self.nodes[0].x
    self.min.y = self.nodes[0].y
    self.min.z = self.nodes[0].z
    self.max.x = self.nodes[0].x
    self.max.y = self.nodes[0].y
    self.max.z = self.nodes[0].z
    for p in self.nodes:
      if p.x > self.max.x:
        self.max.x = p.x
      if p.y > self.max.y:
        self.max.y = p.y
      if p.z > self.max.z:
        self.max.z = p.z
      if p.x < self.min.x:
        self.min.x = p.x
      if p.y < self.min.y:
        self.min.y = p.y
      if p.z < self.min.z:
        self.min.z = p.z
    print "x in [%f, %f]" % (self.min.x, self.max.x)
    print "y in [%f, %f]" % (self.min.y, self.max.y)
    print "z in [%f, %f]" % (self.min.z, self.max.z)

  def export_matlab(self,mname):
        if mname == "":
            return
        mbase = parse_filename(mname)
        file = open(mname,"w+")
        # write header
        line = "function [nodes,elements,boundary,boundary_forces]=" + mbase + "\n"
        # line = line + "_geometry\n"
        file.write(line)
        # write nodes array
        file.write("nodes = [\n")
        for node in self.nodes:
            line = "%f,%f,%f;\n" % (node.x,node.y,node.z)
            file.write(line)
        file.write("];\n")
        # write elements array
        file.write("elements = [\n")
        for elem in self.elements:
            line = ""
            for i in range(len(elem)-1):
                line = line + "%d," % elem[i]
            line = line + "%d;\n" % elem[len(elem)-1]
            file.write(line)
        file.write("];\n")
        # write boundary array
        file.write("boundary = [\n")
        for fixed in self.fixed:
            line = "%d,0,0,0,7;\n" % fixed
            file.write(line)
        if not self.use_forces:
            for presc in self.presc:
                line = "%d,0,%f,0,7;\n" % ( presc, self.displ )
                file.write(line)
        file.write("];\n")  
        # write boundary forces
        file.write("boundary_forces = [\n")
        if self.use_forces:
            for presc in self.presc:
                line = "%d,0,%f,0;\n" % ( presc, self.nodal_yforce)
                file.write(line)
        file.write("];\n")  
        file.close()

##
## Main program
##

if len(argv) < 4:
  print "Syntax: ansys2m nodename elemname mname [displ] [forces]"
  print "Where: nodename - name of ANSYS file with nodes description"
  print "elemname - name of ANSYS file with elements description"
  print "mname - name of output MATLAB file"
  print "Optional parameter displ-prescribed displacements value, default 0.05"
  print "If 'forces' specified, do not use non-zero prescribed displacements"
  print "but use nodal forces instead"
else:  
  nodename = argv[1]
  elename = argv[2]
  mname = argv[3]
  displ = 0.05
  forces_value = 2.08333
  forces = False
  if len(argv) > 4:
    displ = float(argv[4])
    print displ
  if len(argv) > 5:
    if argv[5] == "forces":
      forces = True
  importer = ansys_importer(displ,forces_value,forces) 
  importer.import_files(nodename,elename)
  importer.export_matlab(mname)

